---
title: "[JPA] ORM 패러다임 불일치"
tags:
 - JPA
---



# ORM 패러다임 불일치

1. ### 밀도

   * 객체
     * 다양한 크기의 객체를 만들 수 있음
     * 커스텀한 타입 만들기 쉬움 -> 객체안의 객체, 리스트, 배열
   * 릴레이션
     * 테이블 기본 데이터 타입(UDT(User Defined Type)는 비추)

   <br/>

2. ### 서브 타입

   * 객체
     * 상속 구조 만들기 쉬움
     * 다형성 (Interface를 만들고 Interface를 상속하는 두개의 class)
   * 릴레이션
     * 테이블 상속이라는게 없음
     * 상속 기능을 구현했다 하더라도 표준 기술이 아님
     * 다형적인 관계를 표현할 방법이 없음

   <br/>

3. ### 식별성

   * 객체
     * 레퍼런스 동일성 ( == )
     * 인스턴스 동일성 ( equals() 메소드)
   * 릴레이션
     * Primary Key

   <br/>

4. ### 관계

   * 객체
     * 객체 레퍼런스로 관계 표현
     * 근본적으로 방향이 존재 한다.
     * 다대다 관계를 가질 수 있음
   * 릴레이션
     * 외래키로 관계 표현
     * 방향이라는 의미가 없음. 그냥 Join으로 아무거나 묶을 수 있음
     * 태생적으로 다대다 관계를 못만들고, 조인 테이블 또는 링크 테이블을 사용해서 두개의 1대 다 관계로 풀어야 함

   <br/>

5. ### 데이터 네비게이션

   * 객체
     * 레퍼런스를 이용해서 다른 객체로 이동 가능
     * 콜렉션을 순회할 수도 있음
   * 릴레이션
     * 하지만 그런 방식은 릴레이션에서 데이터를 조회하는데 있어서 매우 비효율적이다.
     * 데이터베이스에 요청을 적게 할 수록 성능이 좋다. 따라서 Join을 쓴다.
     * 하지만, 너무 많이 한번에 가져오려고 해도 문제다.
     * 그렇다고 Lazy loading을 하자니 그것도 문제다. (n+1 select)

   <br/>

   여기서 발생하는 문제는 Study와 Owner 객체로 설명할 수 있다. Study는 하나의 Owner를 가지고 있고 Owner는 여러 Study에 참가하고 있다.

   <br/>

   ```java
   getOwner().getMyStudy().stream.forEach(s -> s.getOwner());
   ```

   이런 코드를 실행하게 됬을 때 릴레이션의 경우는 Owner를 select하고 내가 참여하고 있는 Study들의 목록 ID를 가져와서 Study들을 select한뒤 각각의 study의 Owner정보를 select한다.

   여러번 SQL을 호출하는것은 성능에 좋지 않다. 가능한 한 트랜잭션 내에서 Query를 줄이는것이 성능에 유리하다. 하지만 너무 많은 Join을 하는것도 문제다.

   <br/>

   study에 Lazy loding을 적용하면 Study  목록을 가져올 때 Join을 사용하지 않고 Study만 가져와서 Study를 표시할때 그때마다 Owner 정보를 Select해서 가져오는것이다. -> n+1 select 문제

   애초에 Join을 사용해서 Study를 가져올떄 Owner를 가져오거나, Lazy loding을 적용하되, 50개씩 한번에 가져오면 n+1/50으로 Query를 줄일 수 있다.

   <br/>

   